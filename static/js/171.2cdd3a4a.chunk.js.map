{"version":3,"file":"static/js/171.2cdd3a4a.chunk.js","mappings":"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","sources":["../node_modules/@esri/calcite-components/dist/components/src/utils/form.tsx","../node_modules/@esri/calcite-components/dist/components/src/utils/interactive.tsx","../node_modules/@esri/calcite-components/dist/components/src/utils/browser.ts","../node_modules/@esri/calcite-components/dist/components/src/utils/label.ts"],"sourcesContent":["import { FunctionalComponent, h } from \"@stencil/core\";\nimport { Writable } from \"type-fest\";\nimport { Status } from \"../components\";\nimport { closestElementCrossShadowBoundary, queryElementRoots } from \"./dom\";\n\n/**\n * Any form <Component> with a `calcite<Component>Input` event needs to be included in this array.\n */\nexport const componentsWithInputEvent = [\n  \"calcite-input\",\n  \"calcite-input-number\",\n  \"calcite-input-text\",\n  \"calcite-text-area\",\n];\n\n/**\n * Get the event name to listen for that, when emitted, will clear the\n * validation message that displays after form submission. Only validation\n * messages that are set by the browser will be cleared. If a user sets\n * validationMessage to a custom value, they are responsible for clearing it.\n *\n * Exported for testing purposes.\n *\n * @param componentTag the tag of the component, e.g. \"calcite-input\"\n * @returns the event name\n */\nexport function getClearValidationEventName(componentTag: string): string {\n  const componentTagCamelCase = componentTag\n    .split(\"-\")\n    .map((part: string, index: number) =>\n      index === 0 ? part : `${part[0].toUpperCase()}${part.slice(1)}`,\n    )\n    .join(\"\");\n\n  const clearValidationEvent = `${componentTagCamelCase}${\n    componentsWithInputEvent.includes(componentTag) ? \"Input\" : \"Change\"\n  }`;\n\n  return clearValidationEvent;\n}\n\nexport type MutableValidityState = Writable<ValidityState>;\n\n/**\n * Exported for testing purposes.\n */\nexport const hiddenFormInputSlotName = \"hidden-form-input\";\n\n/**\n * Defines interface for form owning components.\n *\n * Allows calling submit/reset methods on the form.\n */\nexport interface FormOwner {\n  /**\n   * The host element.\n   */\n  readonly el: HTMLElement;\n\n  /**\n   * The ID of the form to associate with the component.\n   *\n   * When not set, the component will be associated with its ancestor form element, if any.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  form: string;\n\n  /**\n   * The form this component is associated with.\n   *\n   * @internal\n   */\n  formEl: HTMLFormElement;\n}\n\n/**\n * Defines interface for form-associated components.\n *\n * Along with the interface, use the matching form utils to help set up the component behavior.\n */\nexport interface FormComponent<T = any> extends FormOwner {\n  /**\n   * When true, this component's value will not be submitted in the form.\n   */\n  disabled: boolean;\n\n  /**\n   * When true, form submit requests will enforce field requirement.\n   *\n   * @todo remove optional in follow-up PR\n   */\n  required?: boolean;\n\n  /**\n   * The name used to submit the value to the associated form.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  name: string;\n\n  /**\n   * This form component's value.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  value: T;\n\n  /**\n   * The initial value for this form component.\n   *\n   * When the form is reset, the value will be set to this property.\n   */\n  defaultValue: T;\n\n  /** The validation icon to display. */\n  validationIcon?: string | boolean;\n\n  /** The validation message to display. */\n  validationMessage?: string;\n\n  /** The validity state of the form component. */\n  validity?: MutableValidityState;\n\n  /**\n   * Hook for components to provide custom form reset behavior.\n   */\n  onFormReset?: () => void;\n\n  /**\n   * Hook for components to sync _extra_ props on the hidden input form element used for form-submitting.\n   *\n   * Note: The following props are set by default: disabled, hidden, name, required, value.\n   */\n  syncHiddenFormInput?: (input: HTMLInputElement) => void;\n}\n\n/**\n * Defines interface for checkable form-associated components.\n *\n * Along with the interface, use the matching form utils to help set up the component behavior.\n */\nexport interface CheckableFormComponent<T = any> extends FormComponent<T> {\n  /**\n   * For boolean-valued components, this property defines whether the associated value is submitted to the form or not.\n   */\n  checked: boolean;\n\n  /**\n   * The initial checked value for this form component.\n   *\n   * When the form is reset, the checked property will be set to this value.\n   */\n  defaultChecked: boolean;\n}\n\nfunction isCheckable(component: FormComponent): component is CheckableFormComponent {\n  return \"checked\" in component;\n}\n\nconst onFormResetMap = new WeakMap<HTMLElement, FormComponent[\"onFormReset\"]>();\nconst formComponentSet = new WeakSet<HTMLElement>();\n\n/**\n * This helps determine if our form component is part of a composite form-associated component.\n *\n * @param form\n * @param formComponentEl\n */\nfunction hasRegisteredFormComponentParent(\n  form: HTMLFormElement,\n  formComponentEl: HTMLElement,\n): boolean {\n  // if we have a parent component using the form ID attribute, we assume it is form-associated\n  const hasParentComponentWithFormIdSet = closestElementCrossShadowBoundary(\n    formComponentEl.parentElement,\n    \"[form]\",\n  );\n\n  if (hasParentComponentWithFormIdSet) {\n    return true;\n  }\n\n  // we use events as a way to test for nested form-associated components across shadow bounds\n  const formComponentRegisterEventName = \"calciteInternalFormComponentRegister\";\n\n  let hasRegisteredFormComponentParent = false;\n\n  form.addEventListener(\n    formComponentRegisterEventName,\n    (event) => {\n      hasRegisteredFormComponentParent = event\n        .composedPath()\n        .some((element) => formComponentSet.has(element as HTMLElement));\n      event.stopPropagation();\n    },\n    { once: true },\n  );\n\n  formComponentEl.dispatchEvent(\n    new CustomEvent(formComponentRegisterEventName, {\n      bubbles: true,\n      composed: true,\n    }),\n  );\n\n  return hasRegisteredFormComponentParent;\n}\n\n// exported for test purposes only\nexport interface ValidationProps {\n  status: Status;\n  message: string;\n  icon: string | boolean;\n}\n\nfunction displayValidationMessage(\n  component: HTMLCalciteInputElement | FormComponent,\n  { status, message, icon }: ValidationProps,\n): void {\n  if (\"status\" in component) {\n    component.status = status;\n  }\n\n  if (\"validationIcon\" in component && typeof component.validationIcon !== \"string\") {\n    component.validationIcon = icon;\n  }\n\n  if (\"validationMessage\" in component && !component.validationMessage) {\n    component.validationMessage = message;\n  }\n}\n\nfunction getValidationComponent(\n  el: HTMLCalciteInputElement,\n  // TODO: create an HTMLCalciteFormAssociatedElement base type\n): HTMLCalciteInputElement | HTMLCalciteRadioButtonGroupElement {\n  // radio-button is formAssociated, but the validation props are on the parent group\n  if (el.nodeName === \"CALCITE-RADIO-BUTTON\") {\n    return closestElementCrossShadowBoundary<HTMLCalciteRadioButtonGroupElement>(\n      el,\n      \"calcite-radio-button-group\",\n    );\n  }\n  return el;\n}\n\nconst invalidEvent = new CustomEvent(\"calciteInvalid\", { bubbles: true, composed: true });\n\nfunction invalidHandler(event: Event) {\n  // target is the hidden input, which is slotted in the actual form component\n  const hiddenInput = event?.target as HTMLInputElement;\n  const hiddenInputMessage = hiddenInput?.validationMessage;\n\n  // not necessarily a calcite-input, but we don't have an HTMLCalciteFormAssociatedElement type\n  const formComponent = getValidationComponent(\n    hiddenInput?.parentElement as HTMLCalciteInputElement,\n  ) as HTMLCalciteInputElement;\n\n  if (!formComponent) {\n    return;\n  }\n\n  const componentTag = formComponent?.nodeName?.toLowerCase();\n  const componentTagParts = componentTag?.split(\"-\");\n\n  if (componentTagParts.length < 2 || componentTagParts[0] !== \"calcite\") {\n    return;\n  }\n\n  // prevent the browser from showing the native validation popover\n  event?.preventDefault();\n\n  if (\"validity\" in formComponent) {\n    formComponent.validity = hiddenInput?.validity;\n  }\n\n  // dispatch a \"calciteInvalid\" so users can set custom validation messages\n  formComponent.dispatchEvent(invalidEvent);\n\n  displayValidationMessage(formComponent, {\n    message: hiddenInputMessage,\n    icon: true,\n    status: \"invalid\",\n  });\n\n  const clearValidationEvent = getClearValidationEventName(componentTag);\n  formComponent.addEventListener(\n    clearValidationEvent,\n    () => {\n      if (\"status\" in formComponent) {\n        formComponent.status = \"idle\";\n      }\n\n      if (\"validationIcon\" in formComponent && !formComponent.validationIcon) {\n        formComponent.validationIcon = false;\n      }\n\n      if (\n        \"validationMessage\" in formComponent &&\n        formComponent.validationMessage === hiddenInputMessage\n      ) {\n        formComponent.validationMessage = \"\";\n      }\n\n      if (\"validity\" in formComponent) {\n        formComponent.validity = hiddenInput?.validity;\n      }\n    },\n    { once: true },\n  );\n}\n\n/**\n * Helper to submit a form.\n *\n * @param component\n * @returns true if its associated form was submitted, false otherwise.\n */\nexport function submitForm(component: FormOwner): boolean {\n  const { formEl } = component;\n\n  if (!formEl) {\n    return false;\n  }\n\n  formEl.addEventListener(\"invalid\", invalidHandler, true);\n  formEl.requestSubmit();\n  formEl.removeEventListener(\"invalid\", invalidHandler, true);\n\n  requestAnimationFrame(() => {\n    const invalidEls = formEl.querySelectorAll(\"[status=invalid]\");\n\n    // focus the first invalid element that has a validation message\n    for (const el of invalidEls) {\n      if ((el as HTMLCalciteInputElement)?.validationMessage) {\n        (el as HTMLCalciteInputElement)?.setFocus();\n        break;\n      }\n    }\n  });\n\n  return true;\n}\n\n/**\n * Helper to reset a form.\n *\n * @param component\n */\nexport function resetForm(component: FormOwner): void {\n  component.formEl?.reset();\n}\n\n/**\n * Helper to set up form interactions on connectedCallback.\n *\n * @param component\n */\nexport function connectForm<T>(component: FormComponent<T>): void {\n  const { el, value } = component;\n  const associatedForm = findAssociatedForm(component);\n\n  if (!associatedForm || hasRegisteredFormComponentParent(associatedForm, el)) {\n    return;\n  }\n\n  component.formEl = associatedForm;\n  component.defaultValue = value;\n\n  if (isCheckable(component)) {\n    component.defaultChecked = component.checked;\n  }\n\n  const boundOnFormReset = (component.onFormReset || onFormReset).bind(component);\n  associatedForm.addEventListener(\"reset\", boundOnFormReset);\n  onFormResetMap.set(component.el, boundOnFormReset);\n  formComponentSet.add(el);\n}\n\n/**\n * Utility method to find a form-component's associated form element.\n *\n * @param component\n */\nexport function findAssociatedForm(component: FormOwner): HTMLFormElement | null {\n  const { el, form } = component;\n\n  return form\n    ? queryElementRoots<HTMLFormElement>(el, { id: form })\n    : closestElementCrossShadowBoundary<HTMLFormElement>(el, \"form\");\n}\n\nfunction onFormReset<T>(this: FormComponent<T>): void {\n  if (\"status\" in this) {\n    this.status = \"idle\";\n  }\n\n  if (\"validationIcon\" in this) {\n    this.validationIcon = false;\n  }\n\n  if (\"validationMessage\" in this) {\n    this.validationMessage = \"\";\n  }\n\n  if (isCheckable(this)) {\n    this.checked = this.defaultChecked;\n    return;\n  }\n\n  this.value = this.defaultValue;\n}\n\n/**\n * Helper to tear down form interactions on disconnectedCallback.\n *\n * @param component\n */\nexport function disconnectForm<T>(component: FormComponent<T>): void {\n  const { el, formEl } = component;\n\n  if (!formEl) {\n    return;\n  }\n\n  const boundOnFormReset = onFormResetMap.get(el);\n  formEl.removeEventListener(\"reset\", boundOnFormReset);\n  onFormResetMap.delete(el);\n  component.formEl = null;\n  formComponentSet.delete(el);\n}\n\n/**\n * Helper for setting the default value on initialization after connectedCallback.\n *\n * Note that this is only needed if the default value cannot be determined on connectedCallback.\n *\n * @param component\n * @param value\n */\nexport function afterConnectDefaultValueSet<T>(component: FormComponent<T>, value: any): void {\n  component.defaultValue = value;\n}\n\nexport const internalHiddenInputInputEvent = \"calciteInternalHiddenInputInput\";\n\nconst hiddenInputInputHandler = (event: Event) => {\n  event.target.dispatchEvent(new CustomEvent(internalHiddenInputInputEvent, { bubbles: true }));\n};\n\nconst removeHiddenInputChangeEventListener = (input: HTMLInputElement) =>\n  input.removeEventListener(\"input\", hiddenInputInputHandler);\n\n/**\n * Helper for maintaining a form-associated's hidden input in sync with the component.\n *\n * Based on Ionic's approach: https://github.com/ionic-team/ionic-framework/blob/e4bf052794af9aac07f887013b9250d2a045eba3/core/src/utils/helpers.ts#L198\n *\n * @param component\n */\nfunction syncHiddenFormInput(component: FormComponent): void {\n  const { el, formEl, name, value } = component;\n  const { ownerDocument } = el;\n\n  const inputs = el.querySelectorAll<HTMLInputElement>(`input[slot=\"${hiddenFormInputSlotName}\"]`);\n\n  if (!formEl || !name) {\n    inputs.forEach((input) => {\n      removeHiddenInputChangeEventListener(input);\n      input.remove();\n    });\n    return;\n  }\n\n  const values = Array.isArray(value) ? value : [value];\n  const extra: any[] = [];\n  const seen = new Set<any>();\n\n  inputs.forEach((input) => {\n    const valueMatch = values.find(\n      (val) =>\n        /* intentional non-strict equality check */\n        val == input.value,\n    );\n\n    if (valueMatch != null) {\n      seen.add(valueMatch);\n      defaultSyncHiddenFormInput(component, input, valueMatch);\n    } else {\n      extra.push(input);\n    }\n  });\n\n  let docFrag: DocumentFragment;\n\n  values.forEach((value) => {\n    if (seen.has(value)) {\n      return;\n    }\n\n    let input = extra.pop();\n\n    if (!input) {\n      input = ownerDocument!.createElement(\"input\");\n      input.slot = hiddenFormInputSlotName;\n    }\n\n    if (!docFrag) {\n      docFrag = ownerDocument!.createDocumentFragment();\n    }\n\n    docFrag.append(input);\n\n    // emits when hidden input is autofilled\n    input.addEventListener(\"input\", hiddenInputInputHandler);\n\n    defaultSyncHiddenFormInput(component, input, value);\n  });\n\n  if (docFrag) {\n    el.append(docFrag);\n  }\n  extra.forEach((input) => {\n    removeHiddenInputChangeEventListener(input);\n    input.remove();\n  });\n}\n\nfunction defaultSyncHiddenFormInput(\n  component: FormComponent,\n  input: HTMLInputElement,\n  value: string,\n): void {\n  const { defaultValue, disabled, form, name, required } = component;\n\n  // keep in sync to prevent losing reset value\n  input.defaultValue = defaultValue;\n  input.disabled = disabled;\n  input.name = name;\n  input.required = required;\n  input.tabIndex = -1;\n\n  // we set the attr as the prop is read-only\n  if (form) {\n    input.setAttribute(\"form\", form);\n  } else {\n    input.removeAttribute(\"form\");\n  }\n\n  if (isCheckable(component)) {\n    input.checked = component.checked;\n\n    // keep in sync to prevent losing reset value\n    input.defaultChecked = component.defaultChecked;\n    // heuristic to support default/on mode from https://html.spec.whatwg.org/multipage/input.html#dom-input-value-default-on\n    input.value = component.checked ? value || \"on\" : \"\";\n  } else {\n    input.value = value || \"\";\n  }\n\n  component.syncHiddenFormInput?.(input);\n\n  const validationComponent = getValidationComponent(component.el as HTMLCalciteInputElement);\n\n  if (validationComponent && \"validity\" in validationComponent) {\n    // mutate the component's validity object to prevent a rerender\n    // https://stenciljs.com/docs/properties#mutable-arrays-and-objects\n    for (const key in { ...input?.validity }) {\n      validationComponent.validity[key] = input.validity[key];\n    }\n  }\n}\n\ninterface HiddenFormInputSlotProps {\n  component: FormComponent;\n}\n\n/**\n * Helper to render the slot for form-associated component's hidden input.\n *\n * If the component has a default slot, this must be placed at the bottom of the component's root container to ensure it is the last child.\n *\n * render(): VNode {\n *   <Host>\n *     <div class={CSS.container}>\n *     // ...\n *     <HiddenFormInputSlot component={this} />\n *     </div>\n *   </Host>\n * }\n *\n * Note that the hidden-form-input Sass mixin must be added to the component's style to apply specific styles.\n *\n * @param root0\n * @param root0.component\n */\nexport const HiddenFormInputSlot: FunctionalComponent<HiddenFormInputSlotProps> = ({\n  component,\n}) => {\n  syncHiddenFormInput(component);\n\n  return <slot name={hiddenFormInputSlotName} />;\n};\n","import { JSXAttributes } from \"@stencil/core/internal\";\nimport { FunctionalComponent, h, VNode } from \"@stencil/core\";\nimport { getUserAgentString } from \"./browser\";\n\nexport interface InteractiveComponent {\n  /**\n   * The host element.\n   */\n  readonly el: InteractiveHTMLElement;\n\n  /**\n   * When true, prevents user interaction.\n   *\n   * Notes:\n   *\n   * This prop should use the @Prop decorator and reflect.\n   * The `disabled` Sass mixin must be added to the component's stylesheet.\n   */\n  disabled: boolean;\n}\n\n/**\n * Exported for testing purposes only.\n *\n * @internal\n */\nexport type InteractiveHTMLElement = HTMLElement & Pick<InteractiveComponent, \"disabled\">;\n\n// ⚠️ browser-sniffing is not a best practice and should be avoided ⚠️\nconst isFirefox = /firefox/i.test(getUserAgentString());\n\ntype ParentElement<T extends HTMLElement = HTMLElement> = T | null;\n\nconst disabledElementToParent: WeakMap<InteractiveHTMLElement, ParentElement> | null = isFirefox\n  ? new WeakMap()\n  : null;\n\nfunction interceptedClick(): void {\n  const { disabled } = this as InteractiveHTMLElement;\n\n  if (!disabled) {\n    HTMLElement.prototype.click.call(this);\n  }\n}\n\nfunction onPointerDown(event: PointerEvent): void {\n  const interactiveElement = event.target as InteractiveHTMLElement;\n\n  if (isFirefox && !disabledElementToParent.get(interactiveElement)) {\n    return;\n  }\n\n  const { disabled } = interactiveElement;\n\n  if (disabled) {\n    // prevent click from moving focus on host\n    event.preventDefault();\n  }\n}\n\nconst nonBubblingWhenDisabledMouseEvents = [\"mousedown\", \"mouseup\", \"click\"];\n\nfunction onNonBubblingWhenDisabledMouseEvent(event: MouseEvent): void {\n  const interactiveElement = event.target as InteractiveHTMLElement;\n\n  if (isFirefox && !disabledElementToParent.get(interactiveElement)) {\n    return;\n  }\n\n  // prevent disallowed mouse events from being emitted on the disabled host (per https://github.com/whatwg/html/issues/5886)\n  // ⚠ we generally avoid stopping propagation of events, but this is needed to adhere to the intended spec changes above ⚠\n  if (interactiveElement.disabled) {\n    event.stopImmediatePropagation();\n    event.preventDefault();\n  }\n}\n\nconst captureOnlyOptions = { capture: true } as const;\n\n/**\n * This helper updates the host element to prevent keyboard interaction on its subtree and sets the appropriate aria attribute for accessibility.\n *\n * This should be used in the `componentDidRender` lifecycle hook.\n *\n * **Notes**\n *\n * this util is not needed for simple components whose root element or elements are an interactive component (custom element or native control). For those cases, set the `disabled` props on the root components instead.\n * technically, users can override `tabindex` and restore keyboard navigation, but this will be considered user error\n *\n * @param component\n */\nexport function updateHostInteraction(component: InteractiveComponent): void {\n  if (component.disabled) {\n    component.el.setAttribute(\"aria-disabled\", \"true\");\n\n    if (component.el.contains(document.activeElement)) {\n      (document.activeElement as HTMLElement).blur();\n    }\n\n    blockInteraction(component);\n\n    return;\n  }\n\n  restoreInteraction(component);\n\n  component.el.removeAttribute(\"aria-disabled\");\n}\n\nfunction blockInteraction(component: InteractiveComponent): void {\n  component.el.click = interceptedClick;\n\n  if (isFirefox) {\n    const currentParent = getParentElement(component);\n    const trackedParent = disabledElementToParent.get(component.el);\n\n    if (trackedParent !== currentParent) {\n      removeInteractionListeners(trackedParent);\n      disabledElementToParent.set(component.el, currentParent);\n    }\n\n    addInteractionListeners(disabledElementToParent.get(component.el));\n    return;\n  }\n\n  addInteractionListeners(component.el);\n}\n\nfunction addInteractionListeners(element: HTMLElement): void {\n  if (!element) {\n    // this early return path is only applicable to Firefox\n    return;\n  }\n\n  element.addEventListener(\"pointerdown\", onPointerDown, captureOnlyOptions);\n  nonBubblingWhenDisabledMouseEvents.forEach((event) =>\n    element.addEventListener(event, onNonBubblingWhenDisabledMouseEvent, captureOnlyOptions),\n  );\n}\n\nfunction getParentElement(component: InteractiveComponent): ParentElement {\n  return (\n    component.el.parentElement || component.el\n  ); /* assume element is host if it has no parent when connected */\n}\n\nfunction restoreInteraction(component: InteractiveComponent): void {\n  delete component.el.click; // fallback on HTMLElement.prototype.click\n\n  if (isFirefox) {\n    removeInteractionListeners(disabledElementToParent.get(component.el));\n    disabledElementToParent.delete(component.el);\n    return;\n  }\n\n  removeInteractionListeners(component.el);\n}\n\nfunction removeInteractionListeners(element: HTMLElement): void {\n  if (!element) {\n    // this early return path is only applicable to Firefox\n    return;\n  }\n\n  element.removeEventListener(\"pointerdown\", onPointerDown, captureOnlyOptions);\n  nonBubblingWhenDisabledMouseEvents.forEach((event) =>\n    element.removeEventListener(event, onNonBubblingWhenDisabledMouseEvent, captureOnlyOptions),\n  );\n}\n\n/**\n * This utility helps disable components consistently in Firefox.\n *\n * It needs to be called in `connectedCallback` and is only needed for Firefox as it does not call capture event listeners before non-capture ones (see https://bugzilla.mozilla.org/show_bug.cgi?id=1731504).\n *\n * @param component\n */\nexport function connectInteractive(component: InteractiveComponent): void {\n  if (!component.disabled || !isFirefox) {\n    return;\n  }\n\n  blockInteraction(component);\n}\n\n/**\n * This utility restores interactivity to disabled components consistently in Firefox.\n *\n * It needs to be called in `disconnectedCallback` and is only needed for Firefox as it does not call capture event listeners before non-capture ones (see https://bugzilla.mozilla.org/show_bug.cgi?id=1731504).\n *\n * @param component\n */\nexport function disconnectInteractive(component: InteractiveComponent): void {\n  if (!isFirefox) {\n    return;\n  }\n\n  restoreInteraction(component);\n}\n\nexport interface InteractiveContainerOptions extends JSXAttributes {\n  disabled: boolean;\n}\n\nexport const CSS = {\n  container: \"interaction-container\",\n};\n\nexport function InteractiveContainer(\n  { disabled }: InteractiveContainerOptions,\n  children: VNode[],\n): FunctionalComponent {\n  return (\n    <div class={CSS.container} inert={disabled}>\n      {...children}\n    </div>\n  );\n}\n","import { Build } from \"@stencil/core\";\n\ninterface NavigatorUAData {\n  brands: Array<{ brand: string; version: string }>;\n  mobile: boolean;\n  platform: string;\n}\n\nfunction getUserAgentData(): NavigatorUAData | undefined {\n  return (navigator as any).userAgentData;\n}\n\nexport function getUserAgentString(): string {\n  if (!Build.isBrowser) {\n    return \"\";\n  }\n\n  const uaData = getUserAgentData();\n\n  return uaData?.brands\n    ? uaData.brands.map(({ brand, version }) => `${brand}/${version}`).join(\" \")\n    : navigator.userAgent;\n}\n","import { closestElementCrossShadowBoundary, isBefore, queryElementRoots } from \"./dom\";\nimport { componentOnReady } from \"./component\";\n\nexport interface LabelableComponent {\n  /**\n   * When true, disabled prevents interaction.\n   */\n  disabled: boolean;\n\n  /**\n   * The host element.\n   */\n  readonly el: HTMLElement;\n\n  /**\n   * Text label.\n   */\n  label?: string;\n\n  /**\n   * The label this component is associated with.\n   */\n  labelEl: HTMLCalciteLabelElement;\n\n  /**\n   * Hook for components to provide custom label click behavior.\n   */\n  onLabelClick: (event: CustomEvent<any>) => void;\n}\n\n/**\n * Exported for testing purposes only\n *\n * @internal\n */\nexport const labelClickEvent = \"calciteInternalLabelClick\";\nexport const labelConnectedEvent = \"calciteInternalLabelConnected\";\nexport const labelDisconnectedEvent = \"calciteInternalLabelDisconnected\";\n\nconst labelTagName = \"calcite-label\";\nconst labelToLabelables = new WeakMap<HTMLCalciteLabelElement, LabelableComponent[]>();\nconst onLabelClickMap = new WeakMap<HTMLCalciteLabelElement, typeof onLabelClick>();\nconst onLabelConnectedMap = new WeakMap<LabelableComponent, typeof onLabelConnected>();\nconst onLabelDisconnectedMap = new WeakMap<LabelableComponent, typeof onLabelDisconnected>();\nconst unlabeledComponents = new Set<LabelableComponent>();\n\nconst findLabelForComponent = (componentEl: HTMLElement): HTMLCalciteLabelElement | null => {\n  const { id } = componentEl;\n\n  const forLabel =\n    id && (queryElementRoots(componentEl, { selector: `${labelTagName}[for=\"${id}\"]` }) as HTMLCalciteLabelElement);\n\n  if (forLabel) {\n    return forLabel;\n  }\n\n  const parentLabel = closestElementCrossShadowBoundary<HTMLCalciteLabelElement>(componentEl, labelTagName);\n\n  if (\n    !parentLabel ||\n    // labelable components within other custom elements are not considered labelable\n    hasAncestorCustomElements(parentLabel, componentEl)\n  ) {\n    return null;\n  }\n\n  return parentLabel;\n};\n\nfunction hasAncestorCustomElements(label: HTMLCalciteLabelElement, componentEl: HTMLElement): boolean {\n  let traversedElements: HTMLElement[];\n  const customElementAncestorCheckEventType = \"custom-element-ancestor-check\";\n\n  const listener = (event: CustomEvent) => {\n    event.stopImmediatePropagation();\n    const composedPath = event.composedPath() as HTMLElement[];\n    traversedElements = composedPath.slice(composedPath.indexOf(componentEl), composedPath.indexOf(label));\n  };\n\n  label.addEventListener(customElementAncestorCheckEventType, listener, { once: true });\n\n  componentEl.dispatchEvent(new CustomEvent(customElementAncestorCheckEventType, { composed: true, bubbles: true }));\n  label.removeEventListener(customElementAncestorCheckEventType, listener);\n\n  const ancestorCustomElements = traversedElements\n    .filter((el) => el !== componentEl && el !== label)\n    .filter((el) => el.tagName?.includes(\"-\"));\n\n  return ancestorCustomElements.length > 0;\n}\n\n/**\n * Helper to set up label interactions on connectedCallback.\n *\n * @param component\n */\nexport function connectLabel(component: LabelableComponent): void {\n  if (!component) {\n    return;\n  }\n\n  const labelEl = findLabelForComponent(component.el);\n\n  if (\n    (onLabelClickMap.has(labelEl) && labelEl === component.labelEl) ||\n    (!labelEl && unlabeledComponents.has(component))\n  ) {\n    return;\n  }\n\n  const boundOnLabelDisconnected = onLabelDisconnected.bind(component);\n\n  if (labelEl) {\n    component.labelEl = labelEl;\n\n    const labelables = labelToLabelables.get(labelEl) || [];\n    labelables.push(component);\n    labelToLabelables.set(labelEl, labelables.sort(sortByDOMOrder));\n\n    if (!onLabelClickMap.has(component.labelEl)) {\n      onLabelClickMap.set(component.labelEl, onLabelClick);\n      component.labelEl.addEventListener(labelClickEvent, onLabelClick);\n    }\n\n    unlabeledComponents.delete(component);\n    document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));\n    onLabelDisconnectedMap.set(component, boundOnLabelDisconnected);\n    document.addEventListener(labelDisconnectedEvent, boundOnLabelDisconnected);\n  } else if (!unlabeledComponents.has(component)) {\n    boundOnLabelDisconnected();\n    document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));\n  }\n}\n/**\n * Helper to tear down label interactions on disconnectedCallback on labelable components.\n *\n * @param component\n */\nexport function disconnectLabel(component: LabelableComponent): void {\n  if (!component) {\n    return;\n  }\n\n  unlabeledComponents.delete(component);\n  document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));\n  document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));\n  onLabelConnectedMap.delete(component);\n  onLabelDisconnectedMap.delete(component);\n\n  if (!component.labelEl) {\n    return;\n  }\n\n  const labelables = labelToLabelables.get(component.labelEl);\n\n  if (labelables.length === 1) {\n    component.labelEl.removeEventListener(labelClickEvent, onLabelClickMap.get(component.labelEl));\n    onLabelClickMap.delete(component.labelEl);\n  }\n\n  labelToLabelables.set(\n    component.labelEl,\n    labelables.filter((labelable) => labelable !== component).sort(sortByDOMOrder),\n  );\n\n  component.labelEl = null;\n}\n\nfunction sortByDOMOrder(a: LabelableComponent, b: LabelableComponent): number {\n  return isBefore(a.el, b.el) ? -1 : 1;\n}\n\n/**\n * Helper to get the label text from a component.\n *\n * @param component\n */\nexport function getLabelText(component: LabelableComponent): string {\n  return component.label || component.labelEl?.textContent?.trim() || \"\";\n}\n\nfunction onLabelClick(this: HTMLCalciteLabelElement, event: CustomEvent<{ sourceEvent: MouseEvent }>): void {\n  const labelClickTarget = event.detail.sourceEvent.target as HTMLElement;\n  const labelables = labelToLabelables.get(this);\n  const clickedLabelable = labelables.find((labelable) => labelable.el === labelClickTarget);\n  const labelableChildClicked = labelables.includes(clickedLabelable);\n\n  if (labelableChildClicked) {\n    // no need to forward click as labelable will receive focus\n    return;\n  }\n\n  const firstLabelable = labelables[0];\n\n  if (firstLabelable.disabled) {\n    return;\n  }\n\n  firstLabelable.onLabelClick(event);\n}\n\nfunction onLabelConnected(this: LabelableComponent): void {\n  if (unlabeledComponents.has(this)) {\n    connectLabel(this);\n  }\n}\n\nfunction onLabelDisconnected(this: LabelableComponent): void {\n  unlabeledComponents.add(this);\n  const boundOnLabelConnected = onLabelConnectedMap.get(this) || onLabelConnected.bind(this);\n  onLabelConnectedMap.set(this, boundOnLabelConnected);\n  document.addEventListener(labelConnectedEvent, boundOnLabelConnected);\n}\n\n/**\n * Helper to associate an explicit label (i.e., using `for`) with a labelable component that does not have an associated label.\n *\n * @param label - the label element\n */\nexport async function associateExplicitLabelToUnlabeledComponent(label: HTMLCalciteLabelElement): Promise<void> {\n  await componentOnReady(label);\n\n  const alreadyLabeled = labelToLabelables.has(label);\n\n  if (alreadyLabeled) {\n    return;\n  }\n\n  const forComponentEl = label.ownerDocument?.getElementById(label.for);\n\n  if (!forComponentEl) {\n    return;\n  }\n\n  requestAnimationFrame(() => {\n    for (const labelable of unlabeledComponents) {\n      if (labelable.el === forComponentEl) {\n        connectLabel(labelable);\n        break;\n      }\n    }\n  });\n}\n"],"names":["componentsWithInputEvent","hiddenFormInputSlotName","isCheckable","component","onFormResetMap","WeakMap","formComponentSet","WeakSet","getValidationComponent","el","nodeName","closestElementCrossShadowBoundary","invalidEvent","CustomEvent","bubbles","composed","invalidHandler","event","_formComponent$nodeNa","hiddenInput","target","hiddenInputMessage","validationMessage","formComponent","parentElement","componentTag","toLowerCase","componentTagParts","split","length","preventDefault","validity","dispatchEvent","_ref","status","message","icon","validationIcon","displayValidationMessage","clearValidationEvent","componentTagCamelCase","map","part","index","concat","toUpperCase","slice","join","includes","getClearValidationEventName","addEventListener","once","submitForm","formEl","requestSubmit","removeEventListener","requestAnimationFrame","invalidEls","querySelectorAll","setFocus","resetForm","_component$formEl","reset","connectForm","value","associatedForm","findAssociatedForm","form","formComponentEl","formComponentRegisterEventName","hasRegisteredFormComponentParent","composedPath","some","element","has","stopPropagation","defaultValue","defaultChecked","checked","boundOnFormReset","onFormReset","bind","set","add","queryElementRoots","id","this","disconnectForm","get","delete","internalHiddenInputInputEvent","hiddenInputInputHandler","removeHiddenInputChangeEventListener","input","defaultSyncHiddenFormInput","_component$syncHidden","disabled","name","required","tabIndex","setAttribute","removeAttribute","syncHiddenFormInput","call","validationComponent","key","_objectSpread","HiddenFormInputSlot","_ref2","ownerDocument","inputs","forEach","remove","values","Array","isArray","extra","seen","Set","docFrag","valueMatch","find","val","push","pop","createElement","slot","createDocumentFragment","append","h","isFirefox","test","Build","isBrowser","uaData","navigator","userAgentData","brands","brand","version","userAgent","getUserAgentString","disabledElementToParent","interceptedClick","HTMLElement","prototype","click","onPointerDown","interactiveElement","nonBubblingWhenDisabledMouseEvents","onNonBubblingWhenDisabledMouseEvent","stopImmediatePropagation","captureOnlyOptions","capture","updateHostInteraction","contains","document","activeElement","blur","blockInteraction","restoreInteraction","currentParent","getParentElement","trackedParent","removeInteractionListeners","addInteractionListeners","connectInteractive","disconnectInteractive","CSS","container","InteractiveContainer","children","class","inert","labelClickEvent","labelConnectedEvent","labelDisconnectedEvent","labelTagName","labelToLabelables","onLabelClickMap","onLabelConnectedMap","onLabelDisconnectedMap","unlabeledComponents","findLabelForComponent","componentEl","forLabel","selector","parentLabel","label","traversedElements","customElementAncestorCheckEventType","listener","indexOf","ancestorCustomElements","filter","_el$tagName","tagName","hasAncestorCustomElements","connectLabel","labelEl","boundOnLabelDisconnected","onLabelDisconnected","labelables","sort","sortByDOMOrder","onLabelClick","disconnectLabel","labelable","a","b","isBefore","getLabelText","_component$labelEl","textContent","trim","labelClickTarget","detail","sourceEvent","clickedLabelable","firstLabelable","onLabelConnected","boundOnLabelConnected","async","associateExplicitLabelToUnlabeledComponent","_label$ownerDocument","componentOnReady","forComponentEl","getElementById","for"],"sourceRoot":""}